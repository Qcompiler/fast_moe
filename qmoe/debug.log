      # if row_id == 0:
      #     u16_lo = a1 & 0xFFFF
      #     u16_hi = (a1 >> 16) & 0xFFFF
      #     a1 = u16_lo.to(tl.float16, bitcast = True)   
      # #   # if A_offset[i] == 0:
      #     a1_ = u16_hi.to(tl.float16, bitcast = True)  
      #     tl.device_print("a1", a1)
      #     tl.device_print("a1_", a1_)
      #   tl.device_print("a2", a2)
      #   tl.device_print("a5", a5)
      #   tl.device_print("a6", a6)
      #   tl.device_print("x1", x1)
      #   tl.device_print("x2", x2)
      #   tl.device_print("x3", x3)
      #   tl.device_print("x4", x4)
      #   tl.device_print("all1", all1)
      #   tl.device_print("all2", all2)

          # 获取原始存储
    # print("重新解释为uint32:", uint32_tensor)

    # print(vector)
    # print(uint32_tensor)
    # vector *= 2
    # print(uint32_tensor)
    # exit()
      # 获取原始存储
    # storage = vector.untyped_storage()
    # k = vector.numel()  # 元素数量

    # print(vector[0,0:8])
    # exit()
    # 正确的set_用法 - 第三个参数必须是tuple
    # uint32_tensor = torch.tensor([], dtype=torch.uint64,device=device).set_(storage, 0, (k // 4,))
    # print("重新解释为uint32:", uint32_tensor)